(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{499:function(v,_,e){"use strict";e.r(_);var t=e(2),o=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),_("p",[v._v("从字面上来看，"),_("code",[v._v("async")]),v._v(" 是 "),_("strong",[v._v("异步")]),v._v(" 的简写，"),_("code",[v._v("await")]),v._v(" 则为 "),_("strong",[v._v("等待")]),v._v("，所以很好理解 "),_("code",[v._v("async")]),v._v(" 用于申明一个 "),_("code",[v._v("function")]),v._v(" 是异步的，而 "),_("code",[v._v("await")]),v._v(" 用于等待一个异步方法执行完成。\n"),v._v(" "),_("code",[v._v("async/await")]),v._v(" 其实是 "),_("code",[v._v("Generator")]),v._v(" 的语法糖，它能实现的效果都能用 "),_("code",[v._v("then")]),v._v(" 链来实现，它是为优化  "),_("code",[v._v("then")]),v._v(" 链而开发出来的。")]),v._v(" "),_("h2",{attrs:{id:"对比-promise-优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对比-promise-优势"}},[v._v("#")]),v._v(" 对比 Promise 优势")]),v._v(" "),_("ul",[_("li",[v._v("代码读起来更加同步，"),_("code",[v._v("Promise")]),v._v(" 虽然摆脱了回调地狱，但是 "),_("code",[v._v("then")]),v._v(" 的链式调⽤也会带来额外的阅读负担。")]),v._v(" "),_("li",[_("code",[v._v("Promise")]),v._v(" 传递中间值⾮常麻烦，⽽ "),_("code",[v._v("async/await")]),v._v(" ⼏乎是同步的写法，⾮常优雅。")]),v._v(" "),_("li",[v._v("错误处理友好，"),_("code",[v._v("async/await")]),v._v(" 可以⽤成熟的 "),_("code",[v._v("try/catch")]),v._v("，"),_("code",[v._v("Promise")]),v._v(" 的错误捕获⾮常冗余。")]),v._v(" "),_("li",[v._v("调试友好， "),_("code",[v._v("Promise")]),v._v(" 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个 "),_("code",[v._v(".then")]),v._v(" 代码块中使⽤调试器的步进 "),_("code",[v._v("step-over")]),v._v(" 功能，调试器并不会进⼊后续的 "),_("code",[v._v(".then")]),v._v(" 代码块，因为调试器只能跟踪同步代码的每⼀步。")])])])}),[],!1,null,null,null);_.default=o.exports}}]);