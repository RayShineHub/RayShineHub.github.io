(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{497:function(v,_,e){"use strict";e.r(_);var t=e(1),o=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),_("p",[_("code",[v._v("Promise")]),v._v(" 是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。")]),v._v(" "),_("p",[_("strong",[v._v("所谓 "),_("code",[v._v("Promise")]),v._v("，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果")]),v._v("。从语法上说，"),_("code",[v._v("Promise")]),v._v(" 是一个对象，从它可以获取异步操作的消息。"),_("code",[v._v("Promise")]),v._v(" 提供统一的 "),_("code",[v._v("API")]),v._v("，各种异步操作都可以用同样的方法进行处理。")]),v._v(" "),_("h2",{attrs:{id:"状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#状态"}},[v._v("#")]),v._v(" 状态")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("状态")]),v._v(" "),_("th",[v._v("解释")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[_("code",[v._v("Pending")])]),v._v(" "),_("td",[v._v("进行中")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("Resolved")])]),v._v(" "),_("td",[v._v("已完成")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("Rejected")])]),v._v(" "),_("td",[v._v("已拒绝")])])])]),v._v(" "),_("p",[v._v("当把一件事情交给 "),_("code",[v._v("promise")]),v._v(" 时，它的状态就是 "),_("code",[v._v("Pending")]),v._v("，任务完成了状态就变成了 "),_("code",[v._v("Resolved")]),v._v("、没有完成失败了就变成了 "),_("code",[v._v("Rejected")]),v._v("。")]),v._v(" "),_("div",{staticClass:"custom-block warning"},[_("svg",{staticClass:"svgIcon",attrs:{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"}},[_("g",{attrs:{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"}},[_("circle",{attrs:{cx:"12",cy:"12",r:"9"}}),_("path",{attrs:{d:"M12 8v4"}}),_("path",{attrs:{d:"M12 16h.01"}})])]),_("p",{staticClass:"title"},[v._v("注意")]),_("p",[v._v("一旦从进行状态变成为其他状态就永远不能更改状态了。")])]),_("h2",{attrs:{id:"常用方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用方法"}},[v._v("#")]),v._v(" 常用方法")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("状态")]),v._v(" "),_("th",[v._v("解释")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[_("code",[v._v("then()")])]),v._v(" "),_("td",[v._v("进then方法可以接收两个回调函数作为参数，第一个回调函数是 "),_("code",[v._v("promise")]),v._v(" 对象的状态变为 "),_("code",[v._v("resolved")]),v._v("调用，第二个回调函数是 "),_("code",[v._v("promise")]),v._v(" 对象的状态变为 "),_("code",[v._v("rejected")]),v._v(" 时调用，其中第二个参数可以省略。行中")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("catch()")])]),v._v(" "),_("td",[v._v("该方法相当于 "),_("code",[v._v("then")]),v._v(" 方法的第二个参数，指向 "),_("code",[v._v("reject")]),v._v(" 的回调函数。 不过 "),_("code",[v._v("catch")]),v._v(" 方法还有一个作用，就是 在执行 "),_("code",[v._v("resolve")]),v._v(" 回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入 "),_("code",[v._v("catch")]),v._v(" 方法中。")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("all()")])]),v._v(" "),_("td",[_("strong",[v._v("等待机制")]),v._v("："),_("code",[v._v("Promise")]),v._v(" 全部子实例都成功才算成功，有一个子实例失败就算失败。"),_("br"),v._v("状态由数组中所有事件来决定，当有一个事件的状态为 "),_("code",[v._v("reject")]),v._v("，"),_("code",[v._v("all()")]),v._v("方法的状态就是 "),_("code",[v._v("reject")]),v._v("。")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("race()")])]),v._v(" "),_("td",[_("strong",[v._v("赛跑机制")]),v._v("：要看最先的 "),_("code",[v._v("Promise")]),v._v(" 子实例是成功还是失败。"),_("br"),v._v("状态由最先结束的事件来决定")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("finally()")])]),v._v(" "),_("td",[v._v("用于指定不管 "),_("code",[v._v("Promise")]),v._v(" 对象最后状态如何，都会执行的操作。")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("any()")])]),v._v(" "),_("td",[_("strong",[v._v("等待机制")]),v._v("：有一个子实例成功就算成功，全部子实例失败才算失败")])])])]),v._v(" "),_("h2",{attrs:{id:"特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[v._v("#")]),v._v(" 特点")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("对象的状态不受外界影响。"),_("code",[v._v("promise")]),v._v(" 对象代表一个异步操作，有三种状态，"),_("code",[v._v("pending")]),v._v("（进行中）、"),_("code",[v._v("fulfilled")]),v._v("（已成功）、"),_("code",[v._v("rejected")]),v._v("（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是 promise 这个名字的由来——“承诺”；")])]),v._v(" "),_("li",[_("p",[v._v("一旦状态改变就不会再变，任何时候都可以得到这个结果。"),_("code",[v._v("promise")]),v._v(" 对象的状态改变，只有两种可能：从 "),_("code",[v._v("pending")]),v._v(" 变为 "),_("code",[v._v("fulfilled")]),v._v("，从 "),_("code",[v._v("pending")]),v._v(" 变为 "),_("code",[v._v("rejected")]),v._v("。这时就称为 "),_("code",[v._v("resolved")]),v._v("（已定型）。如果改变已经发生了，你再对 "),_("code",[v._v("promise")]),v._v(" 对象添加回调函数，也会立即得到这个结果。这与事件（"),_("code",[v._v("event")]),v._v("）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。")])])]),v._v(" "),_("h2",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[v._v("无法取消 "),_("code",[v._v("Promise")]),v._v("，一旦新建它就会立即执行，无法中途取消。")]),v._v(" "),_("li",[v._v("如果不设置回调函数，"),_("code",[v._v("Promise")]),v._v(" 内部抛出的错误，不会反应到外部。")]),v._v(" "),_("li",[v._v("当处于 "),_("code",[v._v("pending")]),v._v(" 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。")])]),v._v(" "),_("h2",{attrs:{id:"promise-解决了什么问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#promise-解决了什么问题"}},[v._v("#")]),v._v(" Promise 解决了什么问题")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("异步编程")]),v._v("：可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。")]),v._v(" "),_("li",[_("strong",[v._v("地狱回调")]),v._v("：后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个 ajax 请求嵌套的情况，代码不够直观。")]),v._v(" "),_("li",[_("strong",[v._v("信任问题")]),v._v("：由于回调存在着依赖反转，在使用第三方提供的方法时，存在信任问题。")])])])}),[],!1,null,null,null);_.default=o.exports}}]);